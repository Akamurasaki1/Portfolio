<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æ³¢å½¢ä½œæ›²ã‚¨ãƒ‡ã‚£ã‚¿</title>
<style>
  body { text-align: center; font-family: sans-serif; background: #f8f9fa; }
  canvas { border: 2px solid #007bff; margin-top: 20px; background: white; touch-action: none; }
  button { margin: 10px; padding: 10px 20px; font-size: 16px; }
</style>
</head>
<body>

<h2>æ³¢å½¢ä½œæ›²ã‚¨ãƒ‡ã‚£ã‚¿</h2>
<p>æ³¢å½¢ã‚’ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å½¢ã‚’å¤‰ãˆã¾ã—ã‚‡ã†ã€‚</p>

<!-- æ³¢å½¢ã‚’æç”»ã™ã‚‹ã‚­ãƒ£ãƒ³ãƒã‚¹ -->
<canvas id="waveformCanvas" width="600" height="200"></canvas><br>
<button id="playWave">â–¶ï¸ å†ç”Ÿ</button>
<button id="saveWave">ğŸ’¾ WAVä¿å­˜</button>
<button id="resetWave">ğŸ§¹ ãƒªã‚»ãƒƒãƒˆ</button>

<script>
const canvas = document.getElementById('waveformCanvas');
const ctx = canvas.getContext('2d');
const N = 200; // æ³¢å½¢ã®åˆ†å‰²ç‚¹æ•°
let waveform = Array(N).fill(0);
let isDrawing = false;

// åˆæœŸæç”»
drawWaveform();

// æç”»é–¢æ•°
function drawWaveform() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.beginPath();
  ctx.moveTo(0, canvas.height / 2);
  waveform.forEach((value, i) => {
    const x = (i / (N - 1)) * canvas.width;
    const y = canvas.height / 2 - value * (canvas.height / 2);
    ctx.lineTo(x, y);
  });
  ctx.strokeStyle = 'blue';
  ctx.lineWidth = 2;
  ctx.stroke();
}

// ãƒã‚¦ã‚¹ï¼ã‚¿ãƒƒãƒåº§æ¨™ã‚’æ³¢å½¢ã«åæ˜ 
function updateWaveform(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const index = Math.round((x / canvas.width) * (N - 1));
  const value = -(y / canvas.height) * 2 + 1; // -1ã€œ1ã¸å¤‰æ›
  waveform[index] = Math.max(-1, Math.min(1, value));
  drawWaveform();
}

// ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®šï¼ˆãƒã‚¦ã‚¹ãƒ»ã‚¿ãƒƒãƒå…±é€šï¼‰
const events = ['mousedown', 'touchstart'];
events.forEach(ev => canvas.addEventListener(ev, e => { isDrawing = true; updateWaveform(e.touches ? e.touches[0] : e); }));
['mousemove', 'touchmove'].forEach(ev => canvas.addEventListener(ev, e => { if (isDrawing) updateWaveform(e.touches ? e.touches[0] : e); }));
['mouseup', 'touchend', 'mouseleave'].forEach(ev => canvas.addEventListener(ev, () => isDrawing = false));

// å†ç”Ÿãƒœã‚¿ãƒ³
document.getElementById('playWave').onclick = () => {
  playWaveform(waveform);
};

// ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
document.getElementById('resetWave').onclick = () => {
  waveform = Array(N).fill(0);
  drawWaveform();
};

// ä¿å­˜ãƒœã‚¿ãƒ³
document.getElementById('saveWave').onclick = async () => {
  const audioCtx = new OfflineAudioContext(1, waveform.length, 44100);
  const buffer = audioCtx.createBuffer(1, waveform.length, 44100);
  buffer.copyToChannel(Float32Array.from(waveform), 0);
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(audioCtx.destination);
  source.start();
  const rendered = await audioCtx.startRendering();
  const wav = bufferToWav(rendered);
  const blob = new Blob([wav], { type: "audio/wav" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "waveform.wav";
  a.click();
};

// éŸ³å†ç”Ÿé–¢æ•°
function playWaveform(arr) {
  const audioCtx = new AudioContext();
  const buffer = audioCtx.createBuffer(1, arr.length, 44100);
  buffer.copyToChannel(Float32Array.from(arr), 0);
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(audioCtx.destination);
  source.start();
}

// WAVå¤‰æ›é–¢æ•°
function bufferToWav(buffer) {
  const numOfChan = buffer.numberOfChannels;
  const length = buffer.length * numOfChan * 2 + 44;
  const bufferView = new ArrayBuffer(length);
  const view = new DataView(bufferView);
  const channels = [];
  let offset = 0;
  let pos = 0;

  function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
  function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }

  setUint32(0x46464952);
  setUint32(length - 8);
  setUint32(0x45564157);
  setUint32(0x20746d66);
  setUint32(16);
  setUint16(1);
  setUint16(numOfChan);
  setUint32(buffer.sampleRate);
  setUint32(buffer.sampleRate * 2 * numOfChan);
  setUint16(numOfChan * 2);
  setUint16(16);
  setUint32(0x61746164);
  setUint32(length - pos - 4);

  for (let i = 0; i < numOfChan; i++)
    channels.push(buffer.getChannelData(i));

  while (pos < length) {
    for (let i = 0; i < numOfChan; i++) {
      const sample = Math.max(-1, Math.min(1, channels[i][offset]));
      view.setInt16(pos, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
      pos += 2;
    }
    offset++;
  }
  return bufferView;
}
</script>
</body>
</html>