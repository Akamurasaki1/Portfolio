<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æ³¢å½¢ä½œæ›²ã‚¢ãƒ—ãƒª</title>
<style>
  body { text-align: center; font-family: sans-serif; background: #fafafa; }
  canvas {
    border: 2px solid #007bff;
    touch-action: none;
    margin-top: 20px;
    background: white;
  }
  button {
    margin: 10px;
    padding: 10px 20px;
    font-size: 16px;
  }
</style>
</head>
<body>
<h2>æ³¢å½¢ä½œæ›²ã‚¢ãƒ—ãƒª</h2>
<p>Apple Pencilã‚„æŒ‡ã§æ³¢å½¢ã‚’æã„ã¦ãã ã•ã„ã€‚</p>
<canvas id="waveCanvas" width="800" height="200"></canvas><br>
<button id="playBtn">â–¶ï¸ å†ç”Ÿ</button>
<button id="clearBtn">ğŸ§¹ æ¶ˆå»</button>
<button id="saveBtn">ğŸ’¾ WAVä¿å­˜</button>

<script>
const canvas = document.getElementById("waveCanvas");
const ctx = canvas.getContext("2d");
let drawing = false;
let points = [];

<!-- æ³¢å½¢ã‚’æç”»ã™ã‚‹ã‚­ãƒ£ãƒ³ãƒã‚¹ -->
  <canvas id="waveformCanvas" width="600" height="200"></canvas>
  <br>
  <button id="submitWaveformButton">æ³¢å½¢ã‚’é€ä¿¡</button>
  <div id="waveformResult"></div>

  <script>
    const canvas = document.getElementById('waveformCanvas');
    const ctx = canvas.getContext('2d');
    const waveformResult = document.getElementById('waveformResult');
    const submitWaveformButton = document.getElementById('submitWaveformButton');

    let waveform = Array(100).fill(0); // åˆæœŸæ³¢å½¢ãƒ‡ãƒ¼ã‚¿ (100ç‚¹ã®å¹³å¦ãªæ³¢å½¢)
    let isDrawing = false;

    // æ³¢å½¢ã‚’æç”»ã™ã‚‹é–¢æ•°
    function drawWaveform() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      ctx.moveTo(0, canvas.height / 2);

      waveform.forEach((value, index) => {
        const x = (index / (waveform.length - 1)) * canvas.width;
        const y = canvas.height / 2 - value * (canvas.height / 2);
        ctx.lineTo(x, y);
      });

      ctx.strokeStyle = 'blue';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // ãƒã‚¦ã‚¹æ“ä½œã§æ³¢å½¢ã‚’ç·¨é›†
    canvas.addEventListener('mousedown', (e) => {
      isDrawing = true;
      updateWaveform(e);
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isDrawing) {
        updateWaveform(e);
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDrawing = false;
    });

    canvas.addEventListener('mouseleave', () => {
      isDrawing = false;
    });
// yâ†’éŸ³æ³¢å¤‰æ›
function normalize(arr) {
  const h = canvas.height;
  return arr.map(v => 1 - (v / h) * 2); // -1ã€œ+1
}

// å†ç”Ÿ
document.getElementById("playBtn").onclick = () => {
  if (points.length < 2) return alert("æ³¢å½¢ã‚’æã„ã¦ãã ã•ã„ã€‚");
  const audioCtx = new AudioContext();
  const arr = normalize(points);
  const buffer = audioCtx.createBuffer(1, arr.length, 44100);
  buffer.copyToChannel(Float32Array.from(arr), 0);
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(audioCtx.destination);
  source.start();
};

// æ¶ˆå»
document.getElementById("clearBtn").onclick = () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  points = [];
};

// WAVä¿å­˜
document.getElementById("saveBtn").onclick = async () => {
  if (points.length < 2) return alert("æ³¢å½¢ã‚’æã„ã¦ãã ã•ã„ã€‚");

  const arr = normalize(points);
  const audioCtx = new OfflineAudioContext(1, arr.length, 44100);
  const buffer = audioCtx.createBuffer(1, arr.length, 44100);
  buffer.copyToChannel(Float32Array.from(arr), 0);
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(audioCtx.destination);
  source.start();

  const rendered = await audioCtx.startRendering();
  const wav = bufferToWav(rendered);
  const blob = new Blob([wav], { type: "audio/wav" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "waveform.wav";
  a.click();
};

// WAVå¤‰æ›é–¢æ•°
function bufferToWav(buffer) {
  const numOfChan = buffer.numberOfChannels;
  const length = buffer.length * numOfChan * 2 + 44;
  const bufferView = new ArrayBuffer(length);
  const view = new DataView(bufferView);
  const channels = [];
  let offset = 0;
  let pos = 0;

  // RIFFãƒ˜ãƒƒãƒ€
  function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
  function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }

  setUint32(0x46464952); // "RIFF"
  setUint32(length - 8);
  setUint32(0x45564157); // "WAVE"

  setUint32(0x20746d66); // "fmt "
  setUint32(16);
  setUint16(1);
  setUint16(numOfChan);
  setUint32(buffer.sampleRate);
  setUint32(buffer.sampleRate * 2 * numOfChan);
  setUint16(numOfChan * 2);
  setUint16(16);

  setUint32(0x61746164); // "data"
  setUint32(length - pos - 4);

  for (let i = 0; i < numOfChan; i++)
    channels.push(buffer.getChannelData(i));

  while (pos < length) {
    for (let i = 0; i < numOfChan; i++) {
      const sample = Math.max(-1, Math.min(1, channels[i][offset]));
      view.setInt16(pos, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
      pos += 2;
    }
    offset++;
  }

  return bufferView;
}
</script>
</body>
</html>